Unions are same as structures except that<br>The size of this type is the one of the largest member element.<br>In example below only I,s or c can be accessed SEPERATEY else jargon,, In this case memory is 8 bytes as float is maximum.```Cunion mix_t {  float l;  struct {    short hi;    short lo;    } s;  char c[4];} mix;```Access```mix.lmix.s.himix.s.lowmix.c```Anonymous union  -- no name here declared directly FOR IMPLICITY```struct book2_t {  char title[50];  char author[50];  union {    float dollars;    int yen;  };} book2;```Access, EASY ACCESS ```book2.dollars  // remember dolar or yen not simultaneousbook2.yen```Enumerated vtypes<br>Enumerated types are types that are defined with a set of custom identifiers, known as enumerators<br>```enum colors_t {black, blue, green, cyan, red, purple, yellow, white};```NOTE: this creates a whole new data type from scratch without basing it on any other existing type THAT IS NO INT,FLOAT,STRUCT ETC REQUIRED<br>```Ccolors_t mycolor;mycolor = blue;if (mycolor == green) mycolor = red; ```Values of enumerated types declared with enum are implicitly convertible to an integer type, and vice versa (JANUARY= INT(1) , INT A = JANUARY)```cenum months_t { january=1, february, march, april,                may, june, july, august,                september, october, november, december} y2k;```Enumerated types with enum class -- NO IMPLICIT CONVERSION TO INT just ENUM TYPE```enum class Colors {black, blue, green, cyan, red, purple, yellow, white};Colors mycolor;mycolor = Colors::blue;if (mycolor == Colors::green) mycolor = Colors::red; ```THIS ENUM TYPE IMPLIES MORE CONTROL - in example all are char```enum class EyeColor : char {blue, green, brown}; ```### typedef and using <br>In example C and char are same same and both can be used to initialise```typedef char C;using C = char;C char_array[10]; same as char char_array[10]```**using** used in c++ over **typedef** as advantage in templates		